# REQ-091: エスケープ考慮マーカー検索（until_marker_escaped）

## メタ情報

| 項目 | 値 |
|---|---|
| ステータス | **wont_do** |
| 優先度 | — |
| 依存 | REQ-089（until_marker 基盤） |
| 作成日 | 2026-02-09 |
| 更新日 | 2026-02-09 |
| 却下日 | 2026-02-09 |

## 背景・動機

REQ-089 で実装した `until_marker` は `MemoryExtensions.IndexOf` による素朴なバイト列マッチングを行う。主要なバイトスタッフィングプロトコル（JPEG, SLIP, PPP/HDLC, H.264, COBS）を調査した結果、これらはすべて「マーカーバイト列がエスケープ後のデータ中に出現しない」ことを保証する設計であり、素朴な `IndexOf` で安全に動作することが判明した。

しかし、以下のケースでは素朴な `IndexOf` が偽陽性を起こし得る:

### バイトダブリングエスケープの問題

一部のプロトコルでは、特殊バイトをダブリング（2回繰り返し）でエスケープする。例:

```
デリミタ: 0xAA 0xBB
エスケープ規則: 0xAA → 0xAA 0xAA

データ:    [..., 0xAA, 0xAA, 0xBB, ...]
意味:      [escaped-0xAA] [literal 0xBB]
IndexOf:   位置1で [0xAA, 0xBB] にマッチ → 偽陽性!
```

この場合、`IndexOf` は「エスケープされた 0xAA」の2バイト目と後続の `0xBB` を誤ってマーカーと認識してしまう。

### 調査結果: 主要プロトコルの安全性

| プロトコル | マーカー | スタッフィング方式 | IndexOf 安全 | 理由 |
|---|---|---|---|---|
| JPEG | `0xFF 0xNN` | `0xFF` → `0xFF 0x00` | **安全** | スタッフされた 0xFF の後は常に 0x00。マーカーの 0xNN (!=0x00) と衝突しない |
| SLIP | `0xC0` | `0xC0` → `0xDB 0xDC` | **安全** | デリミタバイト自体がデータから除去される |
| PPP/HDLC | `0x7E` | `0x7E` → `0x7D 0x5E` | **安全** | フラグバイト自体がデータから除去される |
| H.264/H.265 | `0x00 0x00 0x01` | `0x03` 防止バイト挿入 | **安全** | 防止バイトがパターン一致を阻止 |
| MPEG-2 | `0x00 0x00 0x01` | VLCテーブル設計 | **安全** (準拠ストリーム) | 構造的保証 |
| COBS | `0x00` | 全ゼロバイト除去 | **安全** | デリミタバイト自体がデータから除去される |

現時点でバイトダブリングエスケープを使う一般的なバイナリフォーマットは確認されていない（SQL の `''` 等テキストプロトコルには存在する）。

### プロトコル別調査詳細

#### JPEG（ITU-T T.81, Section B.1.1.5）

JPEG マーカーは `0xFF` + 非ゼロバイトの 2 バイト構成（例: EOI = `0xFF 0xD9`、SOI = `0xFF 0xD8`）。SOS（Start of Scan）以降のエントロピー符号化データ内では、データとして自然に出現する `0xFF` バイトに対し、直後に `0x00` を挿入するバイトスタッフィングが行われる。

| 生バイトストリーム | 意味 |
|---|---|
| `0xFF 0x00` | データとしてのリテラル 0xFF（スタッフバイト） |
| `0xFF 0xD9` | EOI マーカー（本物） |
| `0xFF 0xD0`〜`0xFF 0xD7` | リスタートマーカー RST0〜RST7（本物） |

**`IndexOf(0xFF, 0xD9)` が偽陽性を起こすか: 起こさない。** スタッフされた `0xFF` の次バイトは常に `0x00` であり、`0xD9` と衝突しない。生バイトストリーム上で `0xFF 0xD9` が出現する場合は常に本物の EOI マーカーである。

補足: リスタートマーカー `0xFF 0xD0`〜`0xFF 0xD7` もエントロピーデータ中に出現し得るが、これらは本物のマーカーであり、偽陽性ではない。`until_marker(0xFF, 0xD9)` は EOI のみを検索するため影響しない。

#### SLIP — Serial Line IP（RFC 1055）

SLIP はフレームデリミタとして単一バイト END（`0xC0`）を使用する。データ中に `0xC0` が出現する場合は ESC + ESC_END（`0xDB 0xDC`）に置換、`0xDB` が出現する場合は ESC + ESC_ESC（`0xDB 0xDD`）に置換する。

| データバイト | エンコード後 |
|---|---|
| `0xC0` | `0xDB 0xDC` |
| `0xDB` | `0xDB 0xDD` |
| その他 | 変更なし |

**`IndexOf(0xC0)` が偽陽性を起こすか: 起こさない。** デリミタバイト `0xC0` 自体がエンコード後のデータから完全に除去されるため、ストリーム上の `0xC0` は常に本物のフレーム境界。

#### PPP/HDLC（RFC 1662）

PPP は HDLC ライクフレーミングでフラグシーケンス `0x7E` をフレームデリミタとして使用する。データ中の `0x7E` は制御エスケープ `0x7D` + 元バイトの XOR `0x20` に置換される。

| データバイト | エンコード後 |
|---|---|
| `0x7E` | `0x7D 0x5E` |
| `0x7D` | `0x7D 0x5D` |

**`IndexOf(0x7E)` が偽陽性を起こすか: 起こさない。** フラグバイト `0x7E` はエスケープにより `0x7D 0x5E` に変換され、エンコード後のデータに `0x7E` は出現しない。

#### H.264 (AVC) / H.265 (HEVC) — Annex B バイトストリームフォーマット

H.264/H.265 はスタートコードプレフィックス `0x00 0x00 0x01`（3 バイト）または `0x00 0x00 0x00 0x01`（4 バイト）で NAL ユニットを区切る。圧縮データ中にスタートコードと同じパターンが出現するのを防ぐため、エミュレーション防止バイト `0x03` を挿入する。

| 禁止パターン | エスケープ後 |
|---|---|
| `0x00 0x00 0x00` | `0x00 0x00 0x03 0x00` |
| `0x00 0x00 0x01` | `0x00 0x00 0x03 0x01` |
| `0x00 0x00 0x02` | `0x00 0x00 0x03 0x02` |
| `0x00 0x00 0x03` | `0x00 0x00 0x03 0x03` |

**`IndexOf(0x00, 0x00, 0x01)` が偽陽性を起こすか: 起こさない（raw ストリーム上）。** エミュレーション防止バイト `0x03` の挿入により、エンコード後のバイトストリームで `0x00 0x00 0x01` は本物のスタートコードとしてのみ出現する。

注意: デコーダーが `0x03` を除去して RBSP（Raw Byte Sequence Payload）を復元した後のデータに対して `IndexOf` を行うと偽陽性が起きるが、これはフレーミングレベルではなくペイロードデコードの問題であり、`until_marker` のユースケース（フレーム境界検出）とは異なる。

#### MPEG-1 / MPEG-2

MPEG-1/MPEG-2 はスタートコード `0x00 0x00 0x01` + 1 バイトのストリーム ID で構成される 32 ビットのスタートコードを使用する。H.264 とは異なり、明示的なエミュレーション防止バイトは使用しない。代わりに以下の 2 つの構造的メカニズムでスタートコードの偽出現を防止する:

1. **VLC（ハフマン）テーブル設計**: 可変長符号が 23 ビット以上の連続ゼロを生成しないよう設計されている
2. **マーカービット**: タイムスタンプ（PTS/DTS）等の任意値を含む構造に `1` ビットを挿入し、ゼロの連続を断ち切る

**`IndexOf(0x00, 0x00, 0x01)` が偽陽性を起こすか: 準拠ストリームでは起こさない。** ただし保証は明示的なエスケープではなく VLC テーブル設計に依存するため、JPEG/H.264 と比較すると破損データに対する堅牢性は劣る。ヌルパケット（パディング用）にスタートコードパターンが含まれる可能性はあるが、一般的な実装では `0xFF` で埋める。

#### COBS — Consistent Overhead Byte Stuffing

COBS はエンコード後のデータからゼロバイト `0x00` を完全に除去し、`0x00` をフレームデリミタとして使用可能にする。データ中のゼロバイト間の距離を長さプレフィックスとしてエンコードする方式。

**`IndexOf(0x00)` が偽陽性を起こすか: 起こさない。** エンコード後のデータにゼロバイトは一切存在しないため、`0x00` は常に本物のフレーム境界。

### 結論

調査した 6 プロトコルすべてにおいて、バイトスタッフィング/エミュレーション防止の設計目的は**「マーカーバイト列がデータ中に出現しないことを保証する」**ことであり、素朴な `IndexOf` によるマーカー検索は安全に動作する。エスケープ考慮スキャンが必要なケースは、バイトダブリングエスケープのような「エスケープ後のバイト列がマーカーと部分的に重複し得る」方式に限られるが、主要バイナリフォーマットでの採用例は確認されなかった。

参考文献:
- ITU-T T.81 — JPEG 仕様（https://www.w3.org/Graphics/JPEG/itu-t81.pdf）
- RFC 1055 — SLIP（https://www.rfc-editor.org/rfc/rfc1055.html）
- RFC 1662 — PPP in HDLC-like Framing（https://www.rfc-editor.org/rfc/rfc1662.html）
- ISO/IEC 14496-10 — H.264 Annex B
- ISO/IEC 13818-1 — MPEG-2 Systems

## 却下理由

**本REQは対応しない（wont_do）。** 調査の記録として残す。

却下の根拠:

1. **実需がない**: 調査した主要バイナリフォーマット（JPEG, SLIP, PPP/HDLC, H.264/H.265, MPEG-2, COBS）のすべてで、素朴な `IndexOf` によるマーカー検索が安全に動作する。バイトスタッフィングの設計目的が「マーカーバイト列のデータ中での出現を防ぐこと」であり、エスケープ考慮スキャンは不要。
2. **問題が発生するケースが存在しない**: バイトダブリングエスケープを採用する一般的なバイナリフォーマットが確認されていない。理論上の問題に対する実装は YAGNI（You Aren't Gonna Need It）に該当する。
3. **JPEG は既に正しく動作する**: 当初の懸念（REQ-089 の気づき）は誤りだった。JPEG の `0xFF 0x00` スタッフィングにより、`until_marker(0xFF, 0xD9)` は正規の JPEG データで常に正しい結果を返す。
4. **複雑さに見合わない**: エスケープ考慮スキャンは `IndexOf` と比較して O(n) のバイト単位スキャンになり、SIMD 最適化の恩恵を受けられない。実需がない機能のためにパフォーマンスと複雑さを犠牲にする理由がない。

将来、バイトダブリングエスケープを使うバイナリフォーマットの対応が必要になった場合は、新規REQとして起票すること。本ドキュメントの設計候補セクションを出発点として参照可能。

---

## 設計候補（参考記録）

### 追加する機能

- [ ] 新しい組み込み関数 `until_marker_escaped` — エスケープシーケンスを考慮したマーカー検索
- [ ] バイトダブリングエスケープへの対応

### 設計候補

#### 候補A: `until_marker_escaped(sentinel, target, escape_byte)`

```yaml
size: "{until_marker_escaped(0xFF, 0xD9, 0x00)}"
```

意味: `sentinel` (0xFF) を前方スキャンし、次バイトが `target` (0xD9) なら停止、`escape_byte` (0x00) ならスキップして続行、それ以外もスキップして続行。

- 長所: JPEG のパターンに自然にフィット。引数が明確。
- 短所: マーカーが2バイト（sentinel + target）に限定される。3バイト以上のマーカー（H.264 の `0x00 0x00 0x01`）には適用不可。

```
スキャンアルゴリズム:
  while position < scope_end:
    if data[position] == sentinel:
      if position + 1 < scope_end and data[position + 1] == target:
        return position  // マーカー発見
      elif position + 1 < scope_end and data[position + 1] == escape_byte:
        position += 2    // エスケープ、スキップ
      else:
        position += 2    // その他（リスタートマーカー等）、スキップ
    else:
      position += 1
  return scope_end  // 未発見
```

#### 候補B: `until_marker` にスキップパターン引数を追加

```yaml
# 引数3つ以上: 最後の引数がスキップバイト
size: "{until_marker(0xFF, 0xD9, skip=0x00)}"
```

- 短所: 現在の式システムに名前付き引数がない。引数の数だけで意味が変わるのは紛らわしい。

#### 候補C: DSL フィールド属性としてエスケープ規則を指定

```yaml
- name: compressed_data
  type: bytes
  size: "{until_marker(0xFF, 0xD9)}"
  marker_escape: [0xFF, 0x00]
```

- 長所: 式システムを変更せずに済む。フィールドレベルで明示的。
- 短所: `size` 式と `marker_escape` 属性の連携が暗黙的。`until_marker` 以外の size 式と組み合わせた場合の意味が不明確。

### 推奨

**候補A** を推奨。理由:
- 式システム内で完結し、既存の関数呼び出し基盤をそのまま活用できる
- 引数の意味が明確（sentinel, target, escape_byte の3つ）
- JPEG および類似の 2 バイトマーカープロトコルをカバー
- 3バイト以上のマーカーが必要になった場合は別関数で対応可能（YAGNI）

### 備考

- 3バイト以上のマーカー（H.264 の `0x00 0x00 0x01`）も素朴な `IndexOf` で安全であり、エスケープ対応不要
- 正規表現パターンによるエスケープ規則定義は過剰
- バイトダブリングエスケープ以外の複雑なエスケープ方式（XOR変換等）はテキストプロトコル領域の問題であり、BinAnalyzer のスコープ外
